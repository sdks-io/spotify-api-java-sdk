/*
 * SpotifyWebAPILib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

package com.spotify.api.controllers;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.spotify.api.ApiHelper;
import com.spotify.api.Server;
import com.spotify.api.exceptions.ApiException;
import com.spotify.api.exceptions.ForbiddenException;
import com.spotify.api.exceptions.TooManyRequestsException;
import com.spotify.api.exceptions.UnauthorizedException;
import com.spotify.api.http.request.HttpMethod;
import com.spotify.api.http.response.ApiResponse;
import com.spotify.api.models.AudioAnalysisObject;
import com.spotify.api.models.AudioFeaturesObject;
import com.spotify.api.models.ManyAudioFeatures;
import com.spotify.api.models.ManyTracks;
import com.spotify.api.models.MeTracksRequest;
import com.spotify.api.models.MeTracksRequest1;
import com.spotify.api.models.PagingSavedTrackObject;
import com.spotify.api.models.RecommendationsObject;
import com.spotify.api.models.TrackObject;
import io.apimatic.core.ApiCall;
import io.apimatic.core.ErrorCase;
import io.apimatic.core.GlobalConfiguration;
import io.apimatic.coreinterfaces.http.request.ArraySerializationFormat;
import io.apimatic.coreinterfaces.http.request.ResponseClassType;
import java.io.IOException;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;

/**
 * This class lists all the endpoints of the groups.
 */
public final class TracksController extends BaseController {

    /**
     * Initializes the controller.
     * @param globalConfig    Configurations added in client.
     */
    public TracksController(GlobalConfiguration globalConfig) {
        super(globalConfig);
    }

    /**
     * Get Spotify catalog information for a single track identified by its unique Spotify ID.
     * @param  id  Required parameter: Example:
     * @param  market  Optional parameter: Example:
     * @return    Returns the TrackObject wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<TrackObject> getTrack(
            final String id,
            final String market) throws ApiException, IOException {
        return prepareGetTrackRequest(id, market).execute();
    }

    /**
     * Get Spotify catalog information for a single track identified by its unique Spotify ID.
     * @param  id  Required parameter: Example:
     * @param  market  Optional parameter: Example:
     * @return    Returns the TrackObject wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<TrackObject>> getTrackAsync(
            final String id,
            final String market) {
        try { 
            return prepareGetTrackRequest(id, market).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for getTrack.
     */
    private ApiCall<ApiResponse<TrackObject>, ApiException> prepareGetTrackRequest(
            final String id,
            final String market) throws IOException {
        return new ApiCall.Builder<ApiResponse<TrackObject>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/tracks/{id}")
                        .queryParam(param -> param.key("market")
                                .value(market).isRequired(false))
                        .templateParam(param -> param.key("id").value(id)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("oauth_2_0"))
                        .arraySerializationFormat(ArraySerializationFormat.CSV)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .apiResponseDeserializer(
                                response -> ApiHelper.deserialize(response, TrackObject.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.setReason("Bad or expired token. This can happen if the user revoked a token or\nthe access token has expired. You should re-authenticate the user.\n",
                                (reason, context) -> new UnauthorizedException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Bad OAuth request (wrong consumer key, bad nonce, expired\ntimestamp...). Unfortunately, re-authenticating the user won't help here.\n",
                                (reason, context) -> new ForbiddenException(reason, context)))
                        .localErrorCase("429",
                                 ErrorCase.setReason("The app has exceeded its rate limits.\n",
                                (reason, context) -> new TooManyRequestsException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Get Spotify catalog information for multiple tracks based on their Spotify IDs.
     * @param  ids  Required parameter: Example:
     * @param  market  Optional parameter: Example:
     * @return    Returns the ManyTracks wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<ManyTracks> getSeveralTracks(
            final String ids,
            final String market) throws ApiException, IOException {
        return prepareGetSeveralTracksRequest(ids, market).execute();
    }

    /**
     * Get Spotify catalog information for multiple tracks based on their Spotify IDs.
     * @param  ids  Required parameter: Example:
     * @param  market  Optional parameter: Example:
     * @return    Returns the ManyTracks wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<ManyTracks>> getSeveralTracksAsync(
            final String ids,
            final String market) {
        try { 
            return prepareGetSeveralTracksRequest(ids, market).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for getSeveralTracks.
     */
    private ApiCall<ApiResponse<ManyTracks>, ApiException> prepareGetSeveralTracksRequest(
            final String ids,
            final String market) throws IOException {
        return new ApiCall.Builder<ApiResponse<ManyTracks>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/tracks")
                        .queryParam(param -> param.key("ids")
                                .value(ids))
                        .queryParam(param -> param.key("market")
                                .value(market).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("oauth_2_0"))
                        .arraySerializationFormat(ArraySerializationFormat.CSV)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .apiResponseDeserializer(
                                response -> ApiHelper.deserialize(response, ManyTracks.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.setReason("Bad or expired token. This can happen if the user revoked a token or\nthe access token has expired. You should re-authenticate the user.\n",
                                (reason, context) -> new UnauthorizedException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Bad OAuth request (wrong consumer key, bad nonce, expired\ntimestamp...). Unfortunately, re-authenticating the user won't help here.\n",
                                (reason, context) -> new ForbiddenException(reason, context)))
                        .localErrorCase("429",
                                 ErrorCase.setReason("The app has exceeded its rate limits.\n",
                                (reason, context) -> new TooManyRequestsException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Get a list of the songs saved in the current Spotify user's 'Your Music' library.
     * @param  market  Optional parameter: Example:
     * @param  limit  Optional parameter: Example: 20
     * @param  offset  Optional parameter: Example: 0
     * @return    Returns the PagingSavedTrackObject wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<PagingSavedTrackObject> getUsersSavedTracks(
            final String market,
            final Integer limit,
            final Integer offset) throws ApiException, IOException {
        return prepareGetUsersSavedTracksRequest(market, limit, offset).execute();
    }

    /**
     * Get a list of the songs saved in the current Spotify user's 'Your Music' library.
     * @param  market  Optional parameter: Example:
     * @param  limit  Optional parameter: Example: 20
     * @param  offset  Optional parameter: Example: 0
     * @return    Returns the PagingSavedTrackObject wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<PagingSavedTrackObject>> getUsersSavedTracksAsync(
            final String market,
            final Integer limit,
            final Integer offset) {
        try { 
            return prepareGetUsersSavedTracksRequest(market, limit, offset).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for getUsersSavedTracks.
     */
    private ApiCall<ApiResponse<PagingSavedTrackObject>, ApiException> prepareGetUsersSavedTracksRequest(
            final String market,
            final Integer limit,
            final Integer offset) throws IOException {
        return new ApiCall.Builder<ApiResponse<PagingSavedTrackObject>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/me/tracks")
                        .queryParam(param -> param.key("market")
                                .value(market).isRequired(false))
                        .queryParam(param -> param.key("limit")
                                .value((limit != null) ? limit : 20).isRequired(false))
                        .queryParam(param -> param.key("offset")
                                .value((offset != null) ? offset : 0).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("oauth_2_0"))
                        .arraySerializationFormat(ArraySerializationFormat.CSV)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .apiResponseDeserializer(
                                response -> ApiHelper.deserialize(response, PagingSavedTrackObject.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.setReason("Bad or expired token. This can happen if the user revoked a token or\nthe access token has expired. You should re-authenticate the user.\n",
                                (reason, context) -> new UnauthorizedException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Bad OAuth request (wrong consumer key, bad nonce, expired\ntimestamp...). Unfortunately, re-authenticating the user won't help here.\n",
                                (reason, context) -> new ForbiddenException(reason, context)))
                        .localErrorCase("429",
                                 ErrorCase.setReason("The app has exceeded its rate limits.\n",
                                (reason, context) -> new TooManyRequestsException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Save one or more tracks to the current user's 'Your Music' library.
     * @param  ids  Required parameter: Example:
     * @param  body  Optional parameter: Example:
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<Void> saveTracksUser(
            final String ids,
            final MeTracksRequest body) throws ApiException, IOException {
        return prepareSaveTracksUserRequest(ids, body).execute();
    }

    /**
     * Save one or more tracks to the current user's 'Your Music' library.
     * @param  ids  Required parameter: Example:
     * @param  body  Optional parameter: Example:
     * @return    Returns the Void wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<Void>> saveTracksUserAsync(
            final String ids,
            final MeTracksRequest body) {
        try { 
            return prepareSaveTracksUserRequest(ids, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for saveTracksUser.
     */
    private ApiCall<ApiResponse<Void>, ApiException> prepareSaveTracksUserRequest(
            final String ids,
            final MeTracksRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ApiResponse<Void>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/me/tracks")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .queryParam(param -> param.key("ids")
                                .value(ids))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .withAuth(auth -> auth
                                .add("oauth_2_0"))
                        .arraySerializationFormat(ArraySerializationFormat.CSV)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.setReason("Bad or expired token. This can happen if the user revoked a token or\nthe access token has expired. You should re-authenticate the user.\n",
                                (reason, context) -> new UnauthorizedException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Bad OAuth request (wrong consumer key, bad nonce, expired\ntimestamp...). Unfortunately, re-authenticating the user won't help here.\n",
                                (reason, context) -> new ForbiddenException(reason, context)))
                        .localErrorCase("429",
                                 ErrorCase.setReason("The app has exceeded its rate limits.\n",
                                (reason, context) -> new TooManyRequestsException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Remove one or more tracks from the current user's 'Your Music' library.
     * @param  ids  Required parameter: Example:
     * @param  body  Optional parameter: Example:
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<Void> removeTracksUser(
            final String ids,
            final MeTracksRequest1 body) throws ApiException, IOException {
        return prepareRemoveTracksUserRequest(ids, body).execute();
    }

    /**
     * Remove one or more tracks from the current user's 'Your Music' library.
     * @param  ids  Required parameter: Example:
     * @param  body  Optional parameter: Example:
     * @return    Returns the Void wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<Void>> removeTracksUserAsync(
            final String ids,
            final MeTracksRequest1 body) {
        try { 
            return prepareRemoveTracksUserRequest(ids, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for removeTracksUser.
     */
    private ApiCall<ApiResponse<Void>, ApiException> prepareRemoveTracksUserRequest(
            final String ids,
            final MeTracksRequest1 body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ApiResponse<Void>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/me/tracks")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .queryParam(param -> param.key("ids")
                                .value(ids))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .withAuth(auth -> auth
                                .add("oauth_2_0"))
                        .arraySerializationFormat(ArraySerializationFormat.CSV)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.setReason("Bad or expired token. This can happen if the user revoked a token or\nthe access token has expired. You should re-authenticate the user.\n",
                                (reason, context) -> new UnauthorizedException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Bad OAuth request (wrong consumer key, bad nonce, expired\ntimestamp...). Unfortunately, re-authenticating the user won't help here.\n",
                                (reason, context) -> new ForbiddenException(reason, context)))
                        .localErrorCase("429",
                                 ErrorCase.setReason("The app has exceeded its rate limits.\n",
                                (reason, context) -> new TooManyRequestsException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Check if one or more tracks is already saved in the current Spotify user's 'Your Music'
     * library.
     * @param  ids  Required parameter: Example:
     * @return    Returns the List of Boolean wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<List<Boolean>> checkUsersSavedTracks(
            final String ids) throws ApiException, IOException {
        return prepareCheckUsersSavedTracksRequest(ids).execute();
    }

    /**
     * Check if one or more tracks is already saved in the current Spotify user's 'Your Music'
     * library.
     * @param  ids  Required parameter: Example:
     * @return    Returns the List of Boolean wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<List<Boolean>>> checkUsersSavedTracksAsync(
            final String ids) {
        try { 
            return prepareCheckUsersSavedTracksRequest(ids).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for checkUsersSavedTracks.
     */
    private ApiCall<ApiResponse<List<Boolean>>, ApiException> prepareCheckUsersSavedTracksRequest(
            final String ids) throws IOException {
        return new ApiCall.Builder<ApiResponse<List<Boolean>>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/me/tracks/contains")
                        .queryParam(param -> param.key("ids")
                                .value(ids))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("oauth_2_0"))
                        .arraySerializationFormat(ArraySerializationFormat.CSV)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .apiResponseDeserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Boolean[].class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.setReason("Bad or expired token. This can happen if the user revoked a token or\nthe access token has expired. You should re-authenticate the user.\n",
                                (reason, context) -> new UnauthorizedException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Bad OAuth request (wrong consumer key, bad nonce, expired\ntimestamp...). Unfortunately, re-authenticating the user won't help here.\n",
                                (reason, context) -> new ForbiddenException(reason, context)))
                        .localErrorCase("429",
                                 ErrorCase.setReason("The app has exceeded its rate limits.\n",
                                (reason, context) -> new TooManyRequestsException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Get audio features for multiple tracks based on their Spotify IDs.
     * @param  ids  Required parameter: Example:
     * @return    Returns the ManyAudioFeatures wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<ManyAudioFeatures> getSeveralAudioFeatures(
            final String ids) throws ApiException, IOException {
        return prepareGetSeveralAudioFeaturesRequest(ids).execute();
    }

    /**
     * Get audio features for multiple tracks based on their Spotify IDs.
     * @param  ids  Required parameter: Example:
     * @return    Returns the ManyAudioFeatures wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<ManyAudioFeatures>> getSeveralAudioFeaturesAsync(
            final String ids) {
        try { 
            return prepareGetSeveralAudioFeaturesRequest(ids).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for getSeveralAudioFeatures.
     */
    private ApiCall<ApiResponse<ManyAudioFeatures>, ApiException> prepareGetSeveralAudioFeaturesRequest(
            final String ids) throws IOException {
        return new ApiCall.Builder<ApiResponse<ManyAudioFeatures>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/audio-features")
                        .queryParam(param -> param.key("ids")
                                .value(ids))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("oauth_2_0"))
                        .arraySerializationFormat(ArraySerializationFormat.CSV)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .apiResponseDeserializer(
                                response -> ApiHelper.deserialize(response, ManyAudioFeatures.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.setReason("Bad or expired token. This can happen if the user revoked a token or\nthe access token has expired. You should re-authenticate the user.\n",
                                (reason, context) -> new UnauthorizedException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Bad OAuth request (wrong consumer key, bad nonce, expired\ntimestamp...). Unfortunately, re-authenticating the user won't help here.\n",
                                (reason, context) -> new ForbiddenException(reason, context)))
                        .localErrorCase("429",
                                 ErrorCase.setReason("The app has exceeded its rate limits.\n",
                                (reason, context) -> new TooManyRequestsException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Get audio feature information for a single track identified by its unique Spotify ID.
     * @param  id  Required parameter: Example:
     * @return    Returns the AudioFeaturesObject wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<AudioFeaturesObject> getAudioFeatures(
            final String id) throws ApiException, IOException {
        return prepareGetAudioFeaturesRequest(id).execute();
    }

    /**
     * Get audio feature information for a single track identified by its unique Spotify ID.
     * @param  id  Required parameter: Example:
     * @return    Returns the AudioFeaturesObject wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<AudioFeaturesObject>> getAudioFeaturesAsync(
            final String id) {
        try { 
            return prepareGetAudioFeaturesRequest(id).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for getAudioFeatures.
     */
    private ApiCall<ApiResponse<AudioFeaturesObject>, ApiException> prepareGetAudioFeaturesRequest(
            final String id) throws IOException {
        return new ApiCall.Builder<ApiResponse<AudioFeaturesObject>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/audio-features/{id}")
                        .templateParam(param -> param.key("id").value(id)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("oauth_2_0"))
                        .arraySerializationFormat(ArraySerializationFormat.CSV)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .apiResponseDeserializer(
                                response -> ApiHelper.deserialize(response, AudioFeaturesObject.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.setReason("Bad or expired token. This can happen if the user revoked a token or\nthe access token has expired. You should re-authenticate the user.\n",
                                (reason, context) -> new UnauthorizedException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Bad OAuth request (wrong consumer key, bad nonce, expired\ntimestamp...). Unfortunately, re-authenticating the user won't help here.\n",
                                (reason, context) -> new ForbiddenException(reason, context)))
                        .localErrorCase("429",
                                 ErrorCase.setReason("The app has exceeded its rate limits.\n",
                                (reason, context) -> new TooManyRequestsException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Get a low-level audio analysis for a track in the Spotify catalog. The audio analysis
     * describes the track’s structure and musical content, including rhythm, pitch, and timbre.
     * @param  id  Required parameter: Example:
     * @return    Returns the AudioAnalysisObject wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<AudioAnalysisObject> getAudioAnalysis(
            final String id) throws ApiException, IOException {
        return prepareGetAudioAnalysisRequest(id).execute();
    }

    /**
     * Get a low-level audio analysis for a track in the Spotify catalog. The audio analysis
     * describes the track’s structure and musical content, including rhythm, pitch, and timbre.
     * @param  id  Required parameter: Example:
     * @return    Returns the AudioAnalysisObject wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<AudioAnalysisObject>> getAudioAnalysisAsync(
            final String id) {
        try { 
            return prepareGetAudioAnalysisRequest(id).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for getAudioAnalysis.
     */
    private ApiCall<ApiResponse<AudioAnalysisObject>, ApiException> prepareGetAudioAnalysisRequest(
            final String id) throws IOException {
        return new ApiCall.Builder<ApiResponse<AudioAnalysisObject>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/audio-analysis/{id}")
                        .templateParam(param -> param.key("id").value(id)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("oauth_2_0"))
                        .arraySerializationFormat(ArraySerializationFormat.CSV)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .apiResponseDeserializer(
                                response -> ApiHelper.deserialize(response, AudioAnalysisObject.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.setReason("Bad or expired token. This can happen if the user revoked a token or\nthe access token has expired. You should re-authenticate the user.\n",
                                (reason, context) -> new UnauthorizedException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Bad OAuth request (wrong consumer key, bad nonce, expired\ntimestamp...). Unfortunately, re-authenticating the user won't help here.\n",
                                (reason, context) -> new ForbiddenException(reason, context)))
                        .localErrorCase("429",
                                 ErrorCase.setReason("The app has exceeded its rate limits.\n",
                                (reason, context) -> new TooManyRequestsException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Recommendations are generated based on the available information for a given seed entity and
     * matched against similar artists and tracks. If there is sufficient information about the
     * provided seeds, a list of tracks will be returned together with pool size details. For
     * artists and tracks that are very new or obscure there might not be enough data to generate a
     * list of tracks.
     * @param  limit  Optional parameter: Example: 20
     * @param  market  Optional parameter: Example:
     * @param  seedArtists  Optional parameter: Example:
     * @param  seedGenres  Optional parameter: Example:
     * @param  seedTracks  Optional parameter: Example:
     * @param  minAcousticness  Optional parameter: Example:
     * @param  maxAcousticness  Optional parameter: Example:
     * @param  targetAcousticness  Optional parameter: Example:
     * @param  minDanceability  Optional parameter: Example:
     * @param  maxDanceability  Optional parameter: Example:
     * @param  targetDanceability  Optional parameter: Example:
     * @param  minDurationMs  Optional parameter: Example:
     * @param  maxDurationMs  Optional parameter: Example:
     * @param  targetDurationMs  Optional parameter: Example:
     * @param  minEnergy  Optional parameter: Example:
     * @param  maxEnergy  Optional parameter: Example:
     * @param  targetEnergy  Optional parameter: Example:
     * @param  minInstrumentalness  Optional parameter: Example:
     * @param  maxInstrumentalness  Optional parameter: Example:
     * @param  targetInstrumentalness  Optional parameter: Example:
     * @param  minKey  Optional parameter: Example:
     * @param  maxKey  Optional parameter: Example:
     * @param  targetKey  Optional parameter: Example:
     * @param  minLiveness  Optional parameter: Example:
     * @param  maxLiveness  Optional parameter: Example:
     * @param  targetLiveness  Optional parameter: Example:
     * @param  minLoudness  Optional parameter: Example:
     * @param  maxLoudness  Optional parameter: Example:
     * @param  targetLoudness  Optional parameter: Example:
     * @param  minMode  Optional parameter: Example:
     * @param  maxMode  Optional parameter: Example:
     * @param  targetMode  Optional parameter: Example:
     * @param  minPopularity  Optional parameter: Example:
     * @param  maxPopularity  Optional parameter: Example:
     * @param  targetPopularity  Optional parameter: Example:
     * @param  minSpeechiness  Optional parameter: Example:
     * @param  maxSpeechiness  Optional parameter: Example:
     * @param  targetSpeechiness  Optional parameter: Example:
     * @param  minTempo  Optional parameter: Example:
     * @param  maxTempo  Optional parameter: Example:
     * @param  targetTempo  Optional parameter: Example:
     * @param  minTimeSignature  Optional parameter: Example:
     * @param  maxTimeSignature  Optional parameter: Example:
     * @param  targetTimeSignature  Optional parameter: Example:
     * @param  minValence  Optional parameter: Example:
     * @param  maxValence  Optional parameter: Example:
     * @param  targetValence  Optional parameter: Example:
     * @return    Returns the RecommendationsObject wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<RecommendationsObject> getRecommendations(
            final Integer limit,
            final String market,
            final String seedArtists,
            final String seedGenres,
            final String seedTracks,
            final Double minAcousticness,
            final Double maxAcousticness,
            final Double targetAcousticness,
            final Double minDanceability,
            final Double maxDanceability,
            final Double targetDanceability,
            final Integer minDurationMs,
            final Integer maxDurationMs,
            final Integer targetDurationMs,
            final Double minEnergy,
            final Double maxEnergy,
            final Double targetEnergy,
            final Double minInstrumentalness,
            final Double maxInstrumentalness,
            final Double targetInstrumentalness,
            final Integer minKey,
            final Integer maxKey,
            final Integer targetKey,
            final Double minLiveness,
            final Double maxLiveness,
            final Double targetLiveness,
            final Double minLoudness,
            final Double maxLoudness,
            final Double targetLoudness,
            final Integer minMode,
            final Integer maxMode,
            final Integer targetMode,
            final Integer minPopularity,
            final Integer maxPopularity,
            final Integer targetPopularity,
            final Double minSpeechiness,
            final Double maxSpeechiness,
            final Double targetSpeechiness,
            final Double minTempo,
            final Double maxTempo,
            final Double targetTempo,
            final Integer minTimeSignature,
            final Integer maxTimeSignature,
            final Integer targetTimeSignature,
            final Double minValence,
            final Double maxValence,
            final Double targetValence) throws ApiException, IOException {
        return prepareGetRecommendationsRequest(limit, market, seedArtists, seedGenres, seedTracks,
                minAcousticness, maxAcousticness, targetAcousticness, minDanceability,
                maxDanceability, targetDanceability, minDurationMs, maxDurationMs, targetDurationMs,
                minEnergy, maxEnergy, targetEnergy, minInstrumentalness, maxInstrumentalness,
                targetInstrumentalness, minKey, maxKey, targetKey, minLiveness, maxLiveness,
                targetLiveness, minLoudness, maxLoudness, targetLoudness, minMode, maxMode,
                targetMode, minPopularity, maxPopularity, targetPopularity, minSpeechiness,
                maxSpeechiness, targetSpeechiness, minTempo, maxTempo, targetTempo,
                minTimeSignature, maxTimeSignature, targetTimeSignature, minValence, maxValence,
                targetValence).execute();
    }

    /**
     * Recommendations are generated based on the available information for a given seed entity and
     * matched against similar artists and tracks. If there is sufficient information about the
     * provided seeds, a list of tracks will be returned together with pool size details. For
     * artists and tracks that are very new or obscure there might not be enough data to generate a
     * list of tracks.
     * @param  limit  Optional parameter: Example: 20
     * @param  market  Optional parameter: Example:
     * @param  seedArtists  Optional parameter: Example:
     * @param  seedGenres  Optional parameter: Example:
     * @param  seedTracks  Optional parameter: Example:
     * @param  minAcousticness  Optional parameter: Example:
     * @param  maxAcousticness  Optional parameter: Example:
     * @param  targetAcousticness  Optional parameter: Example:
     * @param  minDanceability  Optional parameter: Example:
     * @param  maxDanceability  Optional parameter: Example:
     * @param  targetDanceability  Optional parameter: Example:
     * @param  minDurationMs  Optional parameter: Example:
     * @param  maxDurationMs  Optional parameter: Example:
     * @param  targetDurationMs  Optional parameter: Example:
     * @param  minEnergy  Optional parameter: Example:
     * @param  maxEnergy  Optional parameter: Example:
     * @param  targetEnergy  Optional parameter: Example:
     * @param  minInstrumentalness  Optional parameter: Example:
     * @param  maxInstrumentalness  Optional parameter: Example:
     * @param  targetInstrumentalness  Optional parameter: Example:
     * @param  minKey  Optional parameter: Example:
     * @param  maxKey  Optional parameter: Example:
     * @param  targetKey  Optional parameter: Example:
     * @param  minLiveness  Optional parameter: Example:
     * @param  maxLiveness  Optional parameter: Example:
     * @param  targetLiveness  Optional parameter: Example:
     * @param  minLoudness  Optional parameter: Example:
     * @param  maxLoudness  Optional parameter: Example:
     * @param  targetLoudness  Optional parameter: Example:
     * @param  minMode  Optional parameter: Example:
     * @param  maxMode  Optional parameter: Example:
     * @param  targetMode  Optional parameter: Example:
     * @param  minPopularity  Optional parameter: Example:
     * @param  maxPopularity  Optional parameter: Example:
     * @param  targetPopularity  Optional parameter: Example:
     * @param  minSpeechiness  Optional parameter: Example:
     * @param  maxSpeechiness  Optional parameter: Example:
     * @param  targetSpeechiness  Optional parameter: Example:
     * @param  minTempo  Optional parameter: Example:
     * @param  maxTempo  Optional parameter: Example:
     * @param  targetTempo  Optional parameter: Example:
     * @param  minTimeSignature  Optional parameter: Example:
     * @param  maxTimeSignature  Optional parameter: Example:
     * @param  targetTimeSignature  Optional parameter: Example:
     * @param  minValence  Optional parameter: Example:
     * @param  maxValence  Optional parameter: Example:
     * @param  targetValence  Optional parameter: Example:
     * @return    Returns the RecommendationsObject wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<RecommendationsObject>> getRecommendationsAsync(
            final Integer limit,
            final String market,
            final String seedArtists,
            final String seedGenres,
            final String seedTracks,
            final Double minAcousticness,
            final Double maxAcousticness,
            final Double targetAcousticness,
            final Double minDanceability,
            final Double maxDanceability,
            final Double targetDanceability,
            final Integer minDurationMs,
            final Integer maxDurationMs,
            final Integer targetDurationMs,
            final Double minEnergy,
            final Double maxEnergy,
            final Double targetEnergy,
            final Double minInstrumentalness,
            final Double maxInstrumentalness,
            final Double targetInstrumentalness,
            final Integer minKey,
            final Integer maxKey,
            final Integer targetKey,
            final Double minLiveness,
            final Double maxLiveness,
            final Double targetLiveness,
            final Double minLoudness,
            final Double maxLoudness,
            final Double targetLoudness,
            final Integer minMode,
            final Integer maxMode,
            final Integer targetMode,
            final Integer minPopularity,
            final Integer maxPopularity,
            final Integer targetPopularity,
            final Double minSpeechiness,
            final Double maxSpeechiness,
            final Double targetSpeechiness,
            final Double minTempo,
            final Double maxTempo,
            final Double targetTempo,
            final Integer minTimeSignature,
            final Integer maxTimeSignature,
            final Integer targetTimeSignature,
            final Double minValence,
            final Double maxValence,
            final Double targetValence) {
        try { 
            return prepareGetRecommendationsRequest(limit, market, seedArtists, seedGenres, seedTracks,
            minAcousticness, maxAcousticness, targetAcousticness, minDanceability, maxDanceability,
            targetDanceability, minDurationMs, maxDurationMs, targetDurationMs, minEnergy,
            maxEnergy, targetEnergy, minInstrumentalness, maxInstrumentalness,
            targetInstrumentalness, minKey, maxKey, targetKey, minLiveness, maxLiveness,
            targetLiveness, minLoudness, maxLoudness, targetLoudness, minMode, maxMode, targetMode,
            minPopularity, maxPopularity, targetPopularity, minSpeechiness, maxSpeechiness,
            targetSpeechiness, minTempo, maxTempo, targetTempo, minTimeSignature, maxTimeSignature,
            targetTimeSignature, minValence, maxValence, targetValence).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for getRecommendations.
     */
    private ApiCall<ApiResponse<RecommendationsObject>, ApiException> prepareGetRecommendationsRequest(
            final Integer limit,
            final String market,
            final String seedArtists,
            final String seedGenres,
            final String seedTracks,
            final Double minAcousticness,
            final Double maxAcousticness,
            final Double targetAcousticness,
            final Double minDanceability,
            final Double maxDanceability,
            final Double targetDanceability,
            final Integer minDurationMs,
            final Integer maxDurationMs,
            final Integer targetDurationMs,
            final Double minEnergy,
            final Double maxEnergy,
            final Double targetEnergy,
            final Double minInstrumentalness,
            final Double maxInstrumentalness,
            final Double targetInstrumentalness,
            final Integer minKey,
            final Integer maxKey,
            final Integer targetKey,
            final Double minLiveness,
            final Double maxLiveness,
            final Double targetLiveness,
            final Double minLoudness,
            final Double maxLoudness,
            final Double targetLoudness,
            final Integer minMode,
            final Integer maxMode,
            final Integer targetMode,
            final Integer minPopularity,
            final Integer maxPopularity,
            final Integer targetPopularity,
            final Double minSpeechiness,
            final Double maxSpeechiness,
            final Double targetSpeechiness,
            final Double minTempo,
            final Double maxTempo,
            final Double targetTempo,
            final Integer minTimeSignature,
            final Integer maxTimeSignature,
            final Integer targetTimeSignature,
            final Double minValence,
            final Double maxValence,
            final Double targetValence) throws IOException {
        return new ApiCall.Builder<ApiResponse<RecommendationsObject>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/recommendations")
                        .queryParam(param -> param.key("limit")
                                .value((limit != null) ? limit : 20).isRequired(false))
                        .queryParam(param -> param.key("market")
                                .value(market).isRequired(false))
                        .queryParam(param -> param.key("seed_artists")
                                .value(seedArtists).isRequired(false))
                        .queryParam(param -> param.key("seed_genres")
                                .value(seedGenres).isRequired(false))
                        .queryParam(param -> param.key("seed_tracks")
                                .value(seedTracks).isRequired(false))
                        .queryParam(param -> param.key("min_acousticness")
                                .value(minAcousticness).isRequired(false))
                        .queryParam(param -> param.key("max_acousticness")
                                .value(maxAcousticness).isRequired(false))
                        .queryParam(param -> param.key("target_acousticness")
                                .value(targetAcousticness).isRequired(false))
                        .queryParam(param -> param.key("min_danceability")
                                .value(minDanceability).isRequired(false))
                        .queryParam(param -> param.key("max_danceability")
                                .value(maxDanceability).isRequired(false))
                        .queryParam(param -> param.key("target_danceability")
                                .value(targetDanceability).isRequired(false))
                        .queryParam(param -> param.key("min_duration_ms")
                                .value(minDurationMs).isRequired(false))
                        .queryParam(param -> param.key("max_duration_ms")
                                .value(maxDurationMs).isRequired(false))
                        .queryParam(param -> param.key("target_duration_ms")
                                .value(targetDurationMs).isRequired(false))
                        .queryParam(param -> param.key("min_energy")
                                .value(minEnergy).isRequired(false))
                        .queryParam(param -> param.key("max_energy")
                                .value(maxEnergy).isRequired(false))
                        .queryParam(param -> param.key("target_energy")
                                .value(targetEnergy).isRequired(false))
                        .queryParam(param -> param.key("min_instrumentalness")
                                .value(minInstrumentalness).isRequired(false))
                        .queryParam(param -> param.key("max_instrumentalness")
                                .value(maxInstrumentalness).isRequired(false))
                        .queryParam(param -> param.key("target_instrumentalness")
                                .value(targetInstrumentalness).isRequired(false))
                        .queryParam(param -> param.key("min_key")
                                .value(minKey).isRequired(false))
                        .queryParam(param -> param.key("max_key")
                                .value(maxKey).isRequired(false))
                        .queryParam(param -> param.key("target_key")
                                .value(targetKey).isRequired(false))
                        .queryParam(param -> param.key("min_liveness")
                                .value(minLiveness).isRequired(false))
                        .queryParam(param -> param.key("max_liveness")
                                .value(maxLiveness).isRequired(false))
                        .queryParam(param -> param.key("target_liveness")
                                .value(targetLiveness).isRequired(false))
                        .queryParam(param -> param.key("min_loudness")
                                .value(minLoudness).isRequired(false))
                        .queryParam(param -> param.key("max_loudness")
                                .value(maxLoudness).isRequired(false))
                        .queryParam(param -> param.key("target_loudness")
                                .value(targetLoudness).isRequired(false))
                        .queryParam(param -> param.key("min_mode")
                                .value(minMode).isRequired(false))
                        .queryParam(param -> param.key("max_mode")
                                .value(maxMode).isRequired(false))
                        .queryParam(param -> param.key("target_mode")
                                .value(targetMode).isRequired(false))
                        .queryParam(param -> param.key("min_popularity")
                                .value(minPopularity).isRequired(false))
                        .queryParam(param -> param.key("max_popularity")
                                .value(maxPopularity).isRequired(false))
                        .queryParam(param -> param.key("target_popularity")
                                .value(targetPopularity).isRequired(false))
                        .queryParam(param -> param.key("min_speechiness")
                                .value(minSpeechiness).isRequired(false))
                        .queryParam(param -> param.key("max_speechiness")
                                .value(maxSpeechiness).isRequired(false))
                        .queryParam(param -> param.key("target_speechiness")
                                .value(targetSpeechiness).isRequired(false))
                        .queryParam(param -> param.key("min_tempo")
                                .value(minTempo).isRequired(false))
                        .queryParam(param -> param.key("max_tempo")
                                .value(maxTempo).isRequired(false))
                        .queryParam(param -> param.key("target_tempo")
                                .value(targetTempo).isRequired(false))
                        .queryParam(param -> param.key("min_time_signature")
                                .value(minTimeSignature).isRequired(false))
                        .queryParam(param -> param.key("max_time_signature")
                                .value(maxTimeSignature).isRequired(false))
                        .queryParam(param -> param.key("target_time_signature")
                                .value(targetTimeSignature).isRequired(false))
                        .queryParam(param -> param.key("min_valence")
                                .value(minValence).isRequired(false))
                        .queryParam(param -> param.key("max_valence")
                                .value(maxValence).isRequired(false))
                        .queryParam(param -> param.key("target_valence")
                                .value(targetValence).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("oauth_2_0"))
                        .arraySerializationFormat(ArraySerializationFormat.CSV)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .apiResponseDeserializer(
                                response -> ApiHelper.deserialize(response, RecommendationsObject.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.setReason("Bad or expired token. This can happen if the user revoked a token or\nthe access token has expired. You should re-authenticate the user.\n",
                                (reason, context) -> new UnauthorizedException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Bad OAuth request (wrong consumer key, bad nonce, expired\ntimestamp...). Unfortunately, re-authenticating the user won't help here.\n",
                                (reason, context) -> new ForbiddenException(reason, context)))
                        .localErrorCase("429",
                                 ErrorCase.setReason("The app has exceeded its rate limits.\n",
                                (reason, context) -> new TooManyRequestsException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }
}